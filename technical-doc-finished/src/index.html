
<html lang="en">
<head>
  <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet"  type="text/css" href="style.css">
    <title>Technical Documentation Page</title>
</head>
  <nav id="navbar">
    <header>ETHEREUM</header>
      <ul>
    <li><a class="nav-link" href="#Intro_to_Ethereum">Intro to Ethereum</a></li>
    <li>
      <a class="nav-link" href="#What_is_Ethereum?"
        >What is Ethereum?</a
      >
    </li>
    <li>
      <a class="nav-link" href="#Intro_to_Ether">Intro to Ether</a>
    </li>
    <li><a class="nav-link" href="#Intro_to_dapps">Intro to dapps</a></li>
    <li><a class="nav-link" href="#Web2_vs_Web3">Web2 vs Web3</a></li>
    <li>
      <a class="nav-link" href="#JavaScript_and_Java">JavaScript and Java</a>
    </li>
    <li><a class="nav-link" href="#Transactions">Transactions</a></li>
    <li><a class="nav-link" href="#Blocks">Blocks</a></li>
    <li><a class="nav-link" href="#Ethereum_virtual_machine_(EVM)">Ethereum virtual machine (EVM)</a></li>
    <li><a class="nav-link" href="#Gas_and_Fees">Gas and Fees</a></li>
    <li>
      <a class="nav-link" href="#Node_And_Client">Node And Client
</a>
    </li>
    <li><a class="nav-link" href="#Networks">Networks</a></li>
    <li>
      <a class="nav-link" href="#Introduction_to_the_Ethereum_Stack"
        >Introduction to the Ethereum Stack</a
      >
    </li>
    <li><a class="nav-link" href="#Reference">Reference</a></li>
  </ul>
</nav>
<main id="main-doc">
  <section class="main-section" id="Intro_to_Ethereum">
 </nav>
  <header>Intro to Ethereum</header>
 
  <article>
    
    <p>A blockchain is a public database that is updated and shared across many computers in a network.

"Block" refers to data and state being stored in consecutive groups known as "blocks". If you send ETH to someone else, the transaction data needs to be added to a block to be successful.</p>

"Chain" refers to the fact that each block cryptographically references its parent. In other words, blocks get chained together. The data in a block cannot change without changing all subsequent blocks, which would require the consensus of the entire network.</p>
<p>
Every computer in the network must agree upon each new block and the chain as a whole. These computers are known as "nodes". Nodes ensure everyone interacting with the blockchain has the same data. To accomplish this distributed agreement, blockchains need a consensus mechanism.</p>
<p>
Ethereum currently uses a proof-of-work consensus mechanism. This means that anyone who wants to add new blocks to the chain must solve a difficult puzzle that requires a lot of computing power. Solving the puzzle "proves" that you have done the "work" by using computational resources. Doing this is known as mining. Mining is typically brute force trial and error, but successfully adding a block is rewarded in ETH.</p>

New blocks are broadcast to the nodes in the network, checked and verified, thus updating the state of the blockchain for everyone.</p>
<p>
So to summarize, when you send ETH to someone, the transaction must be mined and included in a new block. The updated state is then shared with the entire network.</p>
  </article>
  <section class="main-section" id="What_is_Ethereum?">
    <header>What is Ethereum?</header>
    <article>
      <p>In the Ethereum universe, there is a single, canonical computer (called the Ethereum Virtual Machine, or EVM) whose state everyone on the Ethereum network agrees on. Everyone who participates in the Ethereum network (every Ethereum node) keeps a copy of the state of this computer. Additionally, any participant can broadcast a request for this computer to perform arbitrary computation. Whenever such a request is broadcast, other participants on the network verify, validate, and carry out ("execute") the computation. This execution causes a state change in the EVM, which is committed and propagated throughout the entire network.</p><p>

Requests for computation are called transaction requests; the record of all transactions and the EVM's present state gets stored on the blockchain, which in turn is stored and agreed upon by all nodes.</p>
      <p>

Cryptographic mechanisms ensure that once transactions are verified as valid and added to the blockchain, they can't be tampered with later. The same mechanisms also ensure that all transactions are signed and executed with appropriate "permissions" (no one should be able to send digital assets from Alice's account, except for Alice herself).</p>
</p>
    </article>
</section>
 <section class="main-section" id="Intro_to_Ether">
    <header>Intro to Ether</header>
    <article>
      <p>
       Ether (ETH) is the native cryptocurrency of Ethereum. The purpose of ether is to allow for a market for computation. Such a market provides an economic incentive for participants to verify and execute transaction requests and provide computational resources to the network.
      </p>

      <p>
        Any participant who broadcasts a transaction request must also offer some amount of ether to the network as a bounty. This bounty will be awarded to whoever eventually does the work of verifying the transaction, executing it, committing it to the blockchain, and broadcasting it to the network.
      </p>
      <p>
        The amount of ether paid corresponds to the time required to do the computation. These bounties also prevent malicious participants from intentionally clogging the network by requesting the execution of infinite computation or other resource-intensive scripts, as these participants must pay for computation time.
      </p>
    </article>
  </section>
<section class="main-section" id="Intro_to_dapps">
<header>Intro To Dapps</header>
    <article>
      <p>A decentralized application (dapp) is an application built on a decentralized network that combines a smart contract and a frontend user interface. On Ethereum, smart contracts are accessible and transparent – like open APIs – so your dapp can even include a smart contract that someone else has written.</p>
      <h3>Definition of a Dapp</h3>
      <p>A dapp has its backend code running on a decentralized peer-to-peer network. Contrast this with an app where the backend code is running on centralized servers.<br>

A dapp can have frontend code and user interfaces written in any language (just like an app) to make calls to its backend. Furthermore, its frontend can get hosted on decentralized storage such as IPFS.</p>
      <ul>
        <li><em>Decentralized</em> - dapps operate on Ethereum, an open public decentralized platform where no one person or group has control</li>
        <li><em>Deterministic</em> - dapps perform the same function irrespective of the environment in which they get executed</li>
        <li><em>Turing complete</em> - dapps can perform any action given the required resources</li>
        <li><em>Isolated</em> - dapps are executed in a virtual environment known as Ethereum Virtual Machine so that if the smart contract has a bug, it won’t hamper the normal functioning of the blockchain network
On smar</li>
      </ul>
      <h3>On Smart Contracts</h3>
      <p>To introduce dapps, we need to introduce smart contracts – a dapp's backend for lack of a better term. For a detailed overview, head to our section on smart contracts.<br>

A smart contract is code that lives on the Ethereum blockchain and runs exactly as programmed. Once smart contracts are deployed on the network you can't change them. Dapps can be decentralized because they are controlled by the logic written into the contract, not an individual or company. This also means you need to design your contracts very carefully and test them thoroughly.</p>
      <h3>Benefits of Dapp Development</h3>
      <ul>
        <li><em>Zero downtime</em> – Once the smart contract is deployed and on the blockchain, the network as a whole will always be able to serve clients looking to interact with the contract. Malicious actors, therefore, cannot launch denial-of-service attacks targeted towards individual dapps.</li>
        <li><em>Privacy</em> – You don’t need to provide real-world identity to deploy or interact with a dapp.</li>
        <li><em>Resistance to censorship</em> – No single entity on the network can block users from submitting transactions, deploying dapps, or reading data from the blockchain.</li>
        <li><em>Complete data integrity</em> – Data stored on the blockchain is immutable and indisputable, thanks to cryptographic primitives. Malicious actors cannot forge transactions or other data that has already been made public.</li>
        <li><em>Trustless computation/verifiable behavior</em> – smart contracts can be analyzed and are guaranteed to execute in predictable ways, without the need to trust a central authority. This is not true in traditional models; for example, when we use online banking systems, we must trust that financial institutions will not misuse our financial data, tamper with records, or get hacked.</li>
      </ul>
     </article>
  </section>
<section class="main-section" id="Web2_vs_Web3">
    <header>Web2 vs Web3</header>
    <p>
     Web2 refers to the version of the internet most of us know today. An internet dominated by companies that provide services in exchange for your personal data. Web3, in the context of Ethereum, refers to decentralized apps that run on the blockchain. These are apps that allow anyone to participate without monetising their personal data.
    </p>
  <h3>Web3 Benefits</h3>
    <p>
      Many Web3 developers have chosen to build dapps because of Ethereum's inherent decentralization:</p>
  <ul>
    <li>Anyone who is on the network has permission to use the service – or in other words, permission isn't required.</li>
    <li>No one can block you or deny you access to the service.</li>
    <li>Payments are built in via the native token, ether (ETH).</li>
    <li>Ethereum is turing-complete, meaning you can pretty much program anything.</li>
  </ul>
  <h3>Web3 Limitations</h3>
  <p>Web3 has some limitations right now:</p>
  <ul>
    <li>Scalability – transactions are slower on web3 because they're decentralized. Changes to state, like a payment, need to be processed by a miner and propagated throughout the network.</li>
    <li>UX – interacting with web3 applications can require extra steps, software, and education. This can be a hurdle to adoption.</li>
    <li>Accessibility – the lack of integration in modern web browsers makes web3 less accessible to most users.</li>
    <li>Cost – most successful dapps put very small portions of their code on the blockchain as it's expensive.</li>
  </ul>
  </section>
<section class="main-section" id="JavaScript_and_Java">
    <header>JavaScript and Java</header>
    <article>
      <p>    JavaScript and Java are similar in some ways but fundamentally different
        in some others. The JavaScript language resembles Java but does not have
        Java's static typing and strong type checking. JavaScript follows most
        Java expression syntax, naming conventions and basic control-flow
        constructs which was the reason why it was renamed from LiveScript to
        JavaScript.</p>
           <p>
        In contrast to Java's compile-time system of classes built by
        declarations, JavaScript supports a runtime system based on a small
        number of data types representing numeric, Boolean, and string values.
        JavaScript has a prototype-based object model instead of the more common
        class-based object model. The prototype-based model provides dynamic
        inheritance; that is, what is inherited can vary for individual objects.
        JavaScript also supports functions without any special declarative
        requirements. Functions can be properties of objects, executing as
        loosely typed methods.
      </p>
       <p>
        JavaScript is a very free-form language compared to Java. You do not
        have to declare all variables, classes, and methods. You do not have to
        be concerned with whether methods are public, private, or protected, and
        you do not have to implement interfaces. Variables, parameters, and
        function return types are not explicitly typed.
      </p>
           To get started with writing JavaScript, open the Scratchpad and write your
      first "Hello world" JavaScript code:
      <code
        >function greetMe(yourName) { alert("Hello " + yourName); }
        greetMe("World");
      </code>
      <code>(function(){
  "use strict";
  /* Start of your code */
  function greetMe(yourName) {
    alert('Hello ' + yourName);
  }

  greetMe('World');
  /* End of your code */
})();
</code>
      <p>JavaScript borrows most of its syntax from Java, C, and C++, but it has also been influenced by Awk, Perl, and Python.

JavaScript is case-sensitive and uses the Unicode character set. For example, the word Früh (which means "early" in German) could be used as a variable name</p>
      <code>let Früh = "foobar"
</code>
      <p>The syntax of comments is the same as in C++ and in many other languages:</p>
      <code>// a one line comment

/* this is a longer,
 * multi-line comment
 */

/* You can't, however, /* nest comments */ SyntaxError */
</code>
      <p>A variable declared using the var or let statement with no assigned value specified has the value of undefined.</p>
       <p>An attempt to access an undeclared variable results in a ReferenceError exception being thrown:</p>
      <code>var a;
console.log('The value of a is ' + a); // The value of a is undefined

console.log('The value of b is ' + b); // The value of b is undefined
var b;
// This one may puzzle you until you read 'Variable hoisting' below

console.log('The value of c is ' + c); // Uncaught ReferenceError: c is not defined

let x;
console.log('The value of x is ' + x); // The value of x is undefined

console.log('The value of y is ' + y); // Uncaught ReferenceError: y is not defined
let y; 
</code>
 
      </article>
  </section>
 <section class="main-section" id="Transactions">
    <header>Transactions</header>
    <article>
      <p>
       Transactions are cryptographically signed instructions from accounts. An account will initiate a transaction to update the state of the Ethereum network. The simplest transaction is transferring ETH from one account to another.</p>
      <h3>Prerequisites</h3>
      <p>To help you better understand this page, we recommend you first read <a href="#Accounts"> Accounts</a> and our<a href="#Intro_to_Ethereum"> introduction to Ethereum</a>.</p>
      <h3>Whats A Transaction?</h3>
      <p>An Ethereum transaction refers to an action initiated by an externally-owned account, in other words an account managed by a human, not a contract. For example, if Bob sends Alice 1 ETH, Bob's account must be debited and Alice's must be credited. This state-changing action takes place within a transaction.</p>
      <p>Transactions, which change the state of the EVM, need to be broadcast to the whole network. Any node can broadcast a request for a transaction to be executed on the EVM; after this happens, a miner will execute the transaction and propagate the resulting state change to the rest of the network.</p>
      <p>Transactions require a fee and must be mined to become valid. To make this overview simpler we'll cover gas fees and mining elsewhere.</p>
      <p>A submitted transaction includes the following information:</p>
      <ul>
        <li>Recipient – the receiving address (if an externally-owned account, the transaction will transfer value. If a contract account, the transaction will execute the contract code)</li>
        <li>Signature – the identifier of the sender. This is generated when the sender's private key signs the transaction and confirms the sender has authorized this transaction</li>
        <li>Value – amount of ETH to transfer from sender to recipient (in WEI, a denomination of ETH)</li>
        <li>Data – optional field to include arbitrary data</li>
        <li>GasLimit – the maximum amount of gas units that can be consumed by the transaction. Units of gas represent computational steps</li>
        <li>MaxPriorityFeePerGas - the maximum amount of gas to be included as a tip to the miner</li>
        <li>MaxFeePerGas - the maximum amount of gas willing to be paid for the transaction (inclusive of baseFeePerGas and maxPriorityFeePerGas)</li>
      </ul>
      </article>
  </section>
  <section class="main-section" id="Blocks">
    <header>Blocks</header>
    <article>
      <p>
        Blocks are batches of transactions with a hash of the previous block in the chain. This links blocks together (in a chain) because hashes are cryptographically derived from the block data. This prevents fraud, because one change in any block in history would invalidate all the following blocks as all subsequent hashes would change and everyone running the blockchain would notice.
      </p>
      <h3>Prerequisites</h3>
      <p>
      Blocks are a very beginner-friendly topic. But to help you better understand this page, we recommend you first read Accounts, Transactions, and our introduction to Ethereum
      </p>
      <h3>Why Blocks?</h3>
      <p>To ensure that all participants on the Ethereum network maintain a synchronized state and agree on the precise history of transactions, we batch transactions into blocks. This means dozens (or hundreds) of transactions are committed, agreed on, and synchronized on all at once.</p>
      <p>By spacing out commits, we give all network participants enough time to come to consensus: even though transaction requests occur dozens of times per second, blocks on Ethereum are committed approximately once every fifteen seconds.</p>
      <h3>How Blocks Work</h3>
      <p>To preserve the transaction history, blocks are strictly ordered (every new block created contains a reference to its parent block), and transactions within blocks are strictly ordered as well. Except in rare cases, at any given time, all participants on the network are in agreement on the exact number and history of blocks, and are working to batch the current live transaction requests into the next block.</p>
      <p>Once a block is put together (mined) by some miner on the network, it is propagated to the rest of the network; all nodes add this block to the end of their blockchain, and mining continues. The exact block-assembly (mining) process and commitment/consensus process is currently specified by Ethereum’s “proof-of-work” protocol.</p>
      <h3> Proof of Work Protocol</h3>
      <p>Proof-of-work means the following:</p>
      <ul>
        <li>Mining nodes have to spend a variable but substantial amount of energy, time, and computational power to produce a “certificate of legitimacy” for a block they propose to the network. This helps protect the network from spam/denial-of-service attacks, among other things, since certificates are expensive to produce.</li>
        <li>Other miners who hear about a new block with a valid certificate of legitimacy must accept the new block as the canonical next block on the blockchain.</li>
        <li>The exact amount of time needed for any given miner to produce this certificate is a random variable with high variance. This ensures that it is unlikely that two miners produce validations for a proposed next block simultaneously; when a miner produces and propagates a certified new block, they can be almost certain that the block will be accepted by the network as the canonical next block on the blockchain, without conflict (though there is a protocol for dealing with conflicts as well in the case that two chains of certified blocks are produced almost simultaneously).</li>
      </ul>
      <h3>Whats in a Block?</h3>
      <ul>
        <li>Timestamp – the time when the block was mined.</li>
        <li>BlockNumber – the length of the blockchain in blocks.</li>
        <li>BaseFeePerGas - the minimum fee per gas required for a transaction to be included in the block.</li>
        <li>Difficulty – the effort required to mine the block.</li>
        <li>MixHash – a unique identifier for that block.</li>
        <li>ParentHash – the unique identifier for the block that came before (this is how blocks are linked in a chain).</li>
        <li>Transactions – the transactions included in the block.</li>
        <li>StateRoot – the entire state of the system: account balances, contract storage, contract code and account nonces are inside.</li>
        <li>Nonce – a hash that, when combined with the mixHash, proves that the block has gone through proof-of-work.</li>
      </ul>
      <h3>Block Time</h3>
      <p>Block time refers to the time it takes to mine a new block. In Ethereum, the average block time is between 12 to 14 seconds and is evaluated after each block. The expected block time is set as a constant at the protocol level and is used to protect the network's security when the miners add more computational power. The average block time gets compared with the expected block time, and if the average block time is higher, then the difficulty is decreased in the block header. If the average block time is smaller, then the difficulty in the block header will be increased.</p>
      <h3>Block Size</h3>
      <p>A final important note is that blocks themselves are bounded in size. Each block has a target size of 15 million gas but the size of blocks will increase or decrease in accordance with network demands, up until the block limit of 30 million gas (2x target block size). The total amount of gas expended by all transactions in the block must be less than the block gas limit. This is important because it ensures that blocks can’t be arbitrarily large. If blocks could be arbitrarily large, then less performant full nodes would gradually stop being able to keep up with the network due to space and speed requirements.</p>
      </article>
  </section>
<section class="main-section" id="Ethereum_virtual_machine_(EVM)">
    <header>Ethereum Virtual Machine (EVM)</header>
    <article>
      <p>
       The EVM’s physical instantiation can’t be described in the same way that one might point to a cloud or an ocean wave, but it does exist as one single entity maintained by thousands of connected computers running an Ethereum client.
      </p>

     
      <p>
       The Ethereum protocol itself exists solely for the purpose of keeping the continuous, uninterrupted, and immutable operation of this special state machine; It's the environment in which all Ethereum accounts and smart contracts live. At any given block in the chain, Ethereum has one and only one 'canonical' state, and the EVM is what defines the rules for computing a new valid state from block to block.
      </p>
      <h3>Prerequisites</h3>
      <p>
       Some basic familiarity with common terminology in computer science such as bytes, memory, and a stack are necessary to understand the EVM. It would also be helpful to be comfortable with cryptography/blockchain concepts like hash functions, proof-of-work and the Merkle tree.
      </p>
      <h3>From Ledger to State Machine</h3>
      <p>
        The analogy of a 'distributed ledger' is often used to describe blockchains like Bitcoin, which enable a decentralized currency using fundamental tools of cryptography. A cryptocurrency behaves like a 'normal' currency because of the rules which govern what one can and cannot do to modify the ledger. For example, a Bitcoin address cannot spend more Bitcoin than it has previously received. These rules underpin all transactions on Bitcoin and many other blockchains.
      </p>
      <p>While Ethereum has its own native cryptocurrency (Ether) that follows almost exactly the same intuitive rules, it also enables a much more powerful function: smart contracts. For this more complex feature, a more sophisticated analogy is required. Instead of a distributed ledger, Ethereum is a distributed state machine. Ethereum's state is a large data structure which holds not only all accounts and balances, but a machine state, which can change from block to block according to a pre-defined set of rules, and which can execute arbitrary machine code. The specific rules of changing state from block to block are defined by the EVM.</p>
      <h3>State</h3>
      <p>In the context of Ethereum, the state is an enormous data structure called a modified Merkle Patricia Trie, which keeps all accounts linked by hashes and reducible to a single root hash stored on the blockchain.</p>
      <h3>EVM Instructions</h3>
      <p>The EVM executes as a stack machine with a depth of 1024 items. Each item is a 256-bit word, which was chosen for the ease of use with 256-bit cryptography (such as Keccak-256 hashes or secp256k1 signatures).</p>
      <p>During execution, the EVM maintains a transient memory (as a word-addressed byte array), which does not persist between transactions.</p>
      <p>Contracts, however, do contain a Merkle Patricia storage trie (as a word-addressable word array), associated with the account in question and part of the global state.</p>
      <p>Compiled smart contract bytecode executes as a number of EVM opcodes, which perform standard stack operations like XOR, AND, ADD, SUB, etc. The EVM also implements a number of blockchain-specific stack operations, such as ADDRESS, BALANCE, BLOCKHASH, etc.</p>
</article>
  </section>
 <section class="main-section" id="Gas_and_Fees">
    <header>Gas and Fees</header>
    <article>
      <p>Gas is essential to the Ethereum network. It is the fuel that allows it to operate, in the same way that a car needs gasoline to run.</p>
      <h3>What is Gas?</h3>
      <p>Gas refers to the unit that measures the amount of computational effort required to execute specific operations on the Ethereum network.</p>
      <p>Since each Ethereum transaction requires computational resources to execute, each transaction requires a fee. Gas refers to the fee required to conduct a transaction on Ethereum successfully.</p>
      <p>Gas fees are paid in Ethereum's native currency, ether (ETH). Gas prices are denoted in gwei, which itself is a denomination of ETH - each gwei is equal to 0.000000001 ETH (10-9 ETH). For example, instead of saying that your gas costs 0.000000001 ether, you can say your gas costs 1 gwei. The word 'gwei' itself means 'giga-wei', and it is equal to 1,000,000,000 wei. Wei itself (named after Wei Dai, creator of b-money) is the smallest unit of ETH.</p>
      <h3>Base Fee</h3>
      <p>Every block has a base fee which acts as a reserve price. To be eligible for inclusion in a block the offered price per gas must at least equal the base fee. The base fee is calculated independently of the current block and is instead determined by the blocks before it - making transaction fees more predictable for users. When the block is mined this base fee is "burned", removing it from circulation.</p>
      <p>The base fee is calculated by a formula that compares the size of the previous block (the amount of gas used for all the transactions) with the target size. The base fee will increase by a maximum of 12.5% per block if the target block size is exceeded. This exponential growth makes it economically non-viable for block size to remain high indefinitely.</p>
      <h3>Max Fee</h3>
      <p>To execute a transaction on the network, users can specify a maximum limit they are willing to pay for their transaction to be executed. This optional parameter is known as the maxFeePerGas. For a transaction to be executed, the max fee must exceed the sum of the base fee and the tip. The transaction sender is refunded the difference between the max fee and the sum of the base fee and tip.</p>
      <h3>Calculating Fees</h3>
      <p>One of the main benefits of the London upgrade is improving the user's experience when setting transaction fees. For wallets that support the upgrade, instead of explicitly stating how much you are willing to pay to get your transaction through, wallet providers will automatically set a recommended transaction fee (base fee + recommended priority fee) to reduce the amount of complexity burdened onto their users.</p>
      <h3>EIP-1559</h3>
      <p>The implementation of EIP-1559 in the London Upgrade made the transaction fee mechanism more complex than the previous gas price auction, but it has the advantage of making gas fees more predictable, resulting in a more efficient transaction fee market. Users can submit transactions with a maxFeePerGas corresponding to how much they are willing to pay for the transaction to be executing, knowing that they will not pay more than the market price for gas (baseFeePerGas), and get any extra, minus their tip, refunded.</p>
      <h3>Why do Gas Fees Exist?</h3>
      <p>In short, gas fees help keep the Ethereum network secure. By requiring a fee for every computation executed on the network, we prevent bad actors from spamming the network. In order to avoid accidental or hostile infinite loops or other computational wastage in code, each transaction is required to set a limit to how many computational steps of code execution it can use. The fundamental unit of computation is "gas".</p><p>Although a transaction includes a limit, any gas not used in a transaction is returned to the user (i.e. max fee - (base fee + tip) is returned).</p>
      <h3>What is Gas Limit?</h3>
      <p>Gas limit refers to the maximum amount of gas you are willing to consume on a transaction. More complicated transactions involving smart contracts require more computational work, so they require a higher gas limit than a simple payment. A standard ETH transfer requires a gas limit of 21,000 units of gas.</p> <p>For example, if you put a gas limit of 50,000 for a simple ETH transfer, the EVM would consume 21,000, and you would get back the remaining 29,000. However, if you specify too little gas, for example, a gas limit of 20,000 for a simple ETH transfer, the EVM will consume your 20,000 gas units attempting to fulfill the transaction, but it will not complete. The EVM then reverts any changes, but since the miner has already done 20k gas units worth of work, that gas is consumed.</p>
      <h3>Why Can Gas Fees Get SO High?</h3>
      <p>High gas fees are due to the popularity of Ethereum. Performing any operation on Ethereum requires consuming gas, and gas space is limited per block. Fees include calculations, storing or manipulating data, or transferring tokens, consuming different amounts of "gas" units. As dapp functionality grows more complex, the number of operations a smart contract performs also grows, meaning each transaction takes up more space of a limited size block. If there's too much demand, users must offer a higher tip amount to try and outbid other users' transactions. A higher tip can make it more likely that your transaction will get into the next block.</p>
      <p>Gas price alone does not actually determine how much we have to pay for a particular transaction. To calculate the transaction fee, we have to multiply the gas used by the transaction fee, which is measured in gwei.</p>
      <h3>Initiatives To Reduce Gas Costs</h3>
      <p>The new network upgrades of Ethereum 2.0 (also known as Eth2 or Serenity) should ultimately address some of the gas fee issues, which will, in turn, enable the platform to process thousands of transactions per second and scale globally.</p>
      <p>Layer 2 scaling is a primary initiative to greatly improve gas costs, user experience and scalability. More on layer 2 scaling.</p>
      <p>The new proof-of-stake model, introduced on the Beacon Chain, should reduce high power consumption and reliance on specialized hardware. This chain will allow the decentralized Ethereum network to agree and keep the network secure, while limiting energy consumption by instead requiring a financial commitment.</p>
      <p>Anyone with at least 32 ETH can stake them and become a validator responsible for processing transactions, validating blocks, and proposing new blocks to add to the chain. Users who have less than 32 ETH can join staking pools.</p>
      <h3>Strategies For You To Reduce Gas Costs</h3>
      <p>If you are looking to reduce gas costs for your ETH, you can set a tip to indicate the priority level of your transaction. Miners will 'work on' and execute transactions that offer a higher tip per gas, as they get to keep the tips that you pay and will be less inclined to execute transactions with lower tips set.</p>
      </article>
  </section>
<section class="main-section" id="Node_And_Client">
    <header>Node And Client</header>
    <article>
      <h3>What are Nodes And Clients?</h3>
      <p>"Node" refers to a running piece of client software. A client is an implementation of Ethereum that verifies all transactions in each block, keeping the network secure and the data accurate.</p>
      <p>Many Ethereum clients exist, in a variety of programming languages such as Go, Rust, JavaScript, Python, C# .NET and Java. What these implementations have in common is they all follow a formal specification (originally the Ethereum Yellow Paper). This specification dictates how the Ethereum network and blockchain functions.</p>
      <h3>Node Types</h3>
      <p>If you want to run your own node, you should understand that there are different types of node that consume data differently. In fact, clients can run 3 different types of node - light, full and archive. There are also options of different sync strategies which enables faster synchronization time. Synchronization refers to how quickly it can get the most up-to-date information on Ethereum's state.</p>
      <h3> Full Node</h3>
      <ul>
        <li>Stores full blockchain data.</li>
        <li>Participates in block validation, verifies all blocks and states.</li>
        <li>All states can be derived from a full node.</li>
        <li>Serves the network and provides data on request.
Light node</li>
      </ul>
      <h3> Light Node</h3>
       <ul>
        <li>Stores the header chain and requests everything else.</li>
        <li>Can verify the validity of the data against the state roots in the block headers.</li>
        <li>Useful for low capacity devices, such as embedded devices or mobile phones, which can't afford to store gigabytes of blockchain data.</li>
        
      </ul> 
      <h3>Archive Node</h3>
      <ul>
        <li>Stores everything kept in the full node and builds an archive of historical states. Needed if you want to query something like an account balance at block #4,000,000, or simply and reliably test your own transactions set without mining them using OpenEthereum.</li>
        <li>These data represent units of terabytes which makes archive nodes less attractive for average users but can be handy for services like block explorers, wallet vendors, and chain analytics.</li>
        </ul> 
      <p>Syncing clients in any mode other than archive will result in pruned blockchain data. This means, there is no archive of all historical states but the full node is able to build them on demand.</p>
      <h3>Why Should I run an Ethereum Node?</h3>
      <p>Running a node allows you to trustlessly and privately use Ethereum while supporting the ecosystem.</p>
      <h3>Benefits to You</h3>
      <p>Running your own node enables you to use Ethereum in a truly private, self-sufficient and trustless manner. You don't need to trust the network because you can verify the data yourself with your client. "Don't trust, verify" is a popular blockchain mantra.</p>
      <ul>
        <li>Your node verifies all the transactions and blocks against consensus rules by itself. This means you don’t have to rely on any other nodes in the network or fully trust them.</li>
        <li>You won't have to leak your addresses and balances to random nodes. Everything can be checked with your own client.</li>
        <li>Your dapp can be more secure and private if you use your own node. Metamask, MyEtherWallet and some other wallets can be easily pointed to your own local node.</li>
        <li>You can program your own custom RPC endpoints.</li>
        <li>You can connect to your node using Inter-process Communications (IPC) or rewrite the node to load your program as a plugin. This grants low latency, which is required to replace your transactions as fast as possible (i.e. frontrunning).</li>
      </ul>
      <h3>Network Benefits</h3>
      <p>A diverse set of nodes is important for Ethereum’s health, security and operational resiliency.</p>
      <ul>
        <li>They provide access to blockchain data for lightweight clients that depend on it. In high peaks of usage, there need to be enough full nodes to help light nodes sync. Light nodes don't store the whole blockchain, instead they verify data via the state roots in block headers. They can request more information from blocks if they need it.</li>
        <li>Full nodes enforce the proof-of-work consensus rules so they can’t be tricked into accepting blocks that don't follow them. This provides extra security in the network because if all the nodes were light nodes, which don't do full verification, miners could attack the network and, for example, create blocks with higher rewards.</li>
      </ul>
      <p>If you run a full node, the whole Ethereum network benefits from it.</p>
      <h3>Running your Own Node</h3>
      <p>Interested in running your own Ethereum client? <a href="https://ethereum.org/en/developers/docs/nodes-and-clients/run-a-node/">Learn how to</a>
  </article>
  
  </section>
<section class="main-section" id="Networks">
    <header>Networks</header>
    <article>
    <p>
    Since Ethereum is a protocol, this means there can be multiple independent "networks" conforming to this protocol that do not interact with each other.
      </p>

      <p>
        Networks are different Ethereum environments you can access for development, testing, or production use cases. Your Ethereum account will work across the different networks but your account balance and transaction history won't carry over from the main Ethereum network. For testing purposes, it's useful to know which networks are available and how to get testnet ETH so you can play around with it.
      </p>

      <h3>Public Networks</h3>

      <p>Public networks are accessible to anyone in the world with an internet connection. Anyone can read or create transactions on a public blockchain and validate the transactions being executed. Agreement on transactions and the state of the network is decided by a consensus of peers.</p>

      <h3>Mainnet</h3>
      <p>
       Mainnet is the primary public Ethereum production blockchain, where actual-value transactions occur on the distributed ledger.
      </p>
      <p>
        When people and exchanges discuss ETH prices, they're talking about Mainnet ETH.
      </p>
      <h3>Testnets</h3>
      <p>In addition to Mainnet, there are public testnets. These are networks used by protocol developers or smart contract developers to test both protocol upgrades as well as potential smart contracts in a production-like environment before deployment to Mainnet. Think of this as an analog to production versus staging servers.</p>
      <p>It’s generally important to test any contract code you write on a testnet before deploying to the Mainnet. If you're building a dapp that integrates with existing smart contracts, most projects have copies deployed to testnets that you can interact with.</p>
      <p>Most testnets use a proof-of-authority consensus mechanism. This means a small number of nodes are chosen to validate transactions and create new blocks – staking their identity in the process. It's hard to incentivise mining on a proof-of-work testnet which can leave it vulnerable.</p>
      <ul>
        <p>Görli</p>
        <li>A proof-of-authority testnet that works across clients.</li>
        <p>Kovan</p>
        <li>A proof-of-authority testnet for those running OpenEthereum clients.</li>
        <p>Rinkeby</p>
        <li>A proof-of-authority testnet for those running Geth client.</li>
        <p>Ropsten</p>
        <li>A proof-of-work testnet. This means it's the best like-for-like representation of Ethereum.</li>
      </ul>
      <h3>Testnet Faucets</h3>
      <p>ETH on testnets has no real value; therefore, there are no markets for testnet ETH. Since you need ETH to actually interact with Ethereum, most people get testnet ETH from faucets. Most faucets are webapps where you can input an address which you request ETH to be sent to.</p>
      <ul>
      
        <li><a href="https://fauceth.komputing.org/">FaucETH</a></li>
        <li><a href="https://faucet.goerli.mudit.blog/">Görli faucet</a></li>
        
        <li><a href="https://faucet.rinkeby.io/">Rinkeby faucet</a></li>
        <li><a href="https://faucet.ropsten.be/">Ropsten faucet</a></li>
        <li><a href="https://fauceth.komputing.org/">Komputing faucet</a></li>
        <li><a href="https://faucets.chain.link/">Chainlink faucet</a></li>
        <li><a href="https://faucet.paradigm.xyz/">Paradigm faucet</a></li>
      </ul>
      <h3>Private Networks</h3>
     <p>An Ethereum network is a private network if its nodes are not connected to a public network (i.e. Mainnet or a testnet). In this context, private only means reserved or isolated, rather than protected or secure.</p>
      <h3>Development Networks</h3>
      <p>To develop an Ethereum application, you'll want to run it on a private network to see how it works before deploying it. Similar to how you create a local server on your computer for web development, you can create a local blockchain instance to test your dapp. This allows for much faster iteration than a public testnet.</p>
      <h3>Consortium Networks</h3>
      <p>The consensus process is controlled by a pre-defined set of nodes that are trusted. For example, a private network of known academic institutions that each govern a single node, and blocks are validated by a threshold of signatories within the network.</p>
      <p>If a public Ethereum network is like the public internet, you can think of a consortium network as a private intranet.</p>
       </article>
  </section>
 <section class="main-section" id="Introduction_to_the_Ethereum_Stack">
    <header>Introduction to the Ethereum Stack</header>
    <article>
      <p>Like any software stack, the complete "Ethereum stack" will vary from project to project depending on your goals.</p>
      <p>There are, however, core components of Ethereum that help provide a mental model for how software applications interact with the Ethereum blockchain. Understanding the layers of the stack will help you understand the different ways that Ethereum can be integrated into software projects.</p>
      <h3>LEVEL 1: ETHEREUM VIRTUAL MACHINE</h3>
      <p>The Ethereum Virtual Machine (EVM) is the runtime environment for smart contracts in Ethereum. All smart contracts and state changes on the Ethereum blockchain are executed by transactions. The EVM handles all of the transaction processing on the Ethereum network.</p>
      <p>As with any virtual machine, the EVM creates a level of abstraction between the executing code and the executing machine (an Ethereum node). Currently the EVM is running on thousands of nodes distributed across the world.</p>
       <p>Under the hood, the EVM uses a set of opcode instructions to execute specific tasks. These (140 unique) opcodes allow the EVM to be Turing-complete, which means the EVM is able to compute just about anything, given enough resources.</p>
      <p>As a dapp developer, you don't need to know much about the EVM other than it exists and that it reliably powers all applications on Ethereum without downtime.

</p>
      <h3>LEVEL 2: SMART CONTRACTS</h3>
      <p>Smart contracts are the executable programs that run on the Ethereum blockchain.</p>
      <p>Smart contracts are written using specific programming languages that compile to EVM bytecode (low-level machine instructions called opcodes).</p>
       <p>Not only do smart contracts serve as open source libraries, they are essentially open API services that are always running and can't be taken down. Smart contracts provide public functions which users and applications (dapps) may interact with, without needing permission. Any application may integrate with deployed smart contracts to compose functionality, such as adding data feeds or to support token swaps. Additionally, anyone can deploy new smart contracts to Ethereum in order to add custom functionality to meet their application's needs.</p>
      <p>As a dapp developer, you'll need to write smart contracts only if you want to add custom functionality on the Ethereum blockchain. You may find you can achieve most or all of your project's needs by merely integrating with existing smart contracts, for instance if you want to support payments in stablecoins or enable decentralized exchange of tokens.</p>
      <h3>LEVEL 3: ETHEREUM NODES</h3>
      <p>In order for an application to interact with the Ethereum blockchain, it must connect to an Ethereum node. Connecting to a node allows you to read blockchain data and/or send transactions to the network</p>
      
      <p>Ethereum nodes are computers running software - an Ethereum client. A client is an implementation of Ethereum that verifies all transactions in each block, keeping the network secure and the data accurate. Ethereum nodes ARE the Ethereum blockchain. They collectively store the state of the Ethereum blockchain and reach consensus on transactions to mutate the blockchain state.</p>
       <p>By connecting your application to an Ethereum node (via the JSON-RPC API), your application is able to read data from the blockchain (such as user account balances) as well as broadcast new transactions to the network (such as transferring ETH between user accounts or executing functions of smart contracts).</p>
      <h3>LEVEL 4: ETHEREUM CLIENT APIS</h3>
      <p>Many convenience libraries (built and maintained by Ethereum's open source community) allow your applications to connect to and communicate with the Ethereum blockchain.</p>
      <p>If your user-facing application is a web app, you may choose to npm install a JavaScript API directly in your frontend. Or perhaps you'll choose to implement this functionality server-side, using a Python or Java API.</p>
      
      
  
      <p>
      While these APIs are not a necessary piece of the stack, they abstract away much of the complexity of interacting directly with an Ethereum node. They also provide utility functions (e.g. converting ETH to Gwei) so as a developer you can spend less time dealing with the intricacies of Ethereum clients and more time focused on the functionality specific to your application.
      </p>
      <h3>LEVEL 5: END-USER APPLICATIONS</h3>

     
      <p>
       At the top level of the stack are user-facing applications. These are the standard applications you regularly use and build today: primarily web and mobile apps.
      </p>
     
      <p>
       The way you develop these user interfaces remains essentially unchanged. Often users will not need to know the application they're using is built using a blockchain.
      </p>
    </article>
  </section>
 <section class="main-section" id="Reference">
    <header>Reference</header>
    <article>
      <ul>
        <li>
          All the documentation in this page is taken from
          <a
            href="https://ethereum.org/en/"
            target="_blank"
            >Ethereum.org</a
          >
        </li>
      </ul>
    </article>
  </section>






  
  
  
  
</html>